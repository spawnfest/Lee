#+TITLE: Lee

* User stories

- As a power user I want to configure tools without looking into their
  code. I want a useful error message instead of a BEAM dump when I
  make an error in the config. I want documentation about all
  configurable parameters, their purpose and type.

- As a designer I want to focus on the business logic instead of
  dealing with the boring configuration-related stuff.

There are a few approaches to this conflict:

[[file:doc/images/explanation.png]]

* Explanation

/Lee/ helps creating type-safe, self-documenting configuration for
Erlang applications. It is basically a data modeling DSL, vaguely
inspired by [[https://tools.ietf.org/html/rfc7950][YANG]], however scaled down /a lot/.

Software configuration is a solved problem. The solution is to gather
all the information about the user-facing commands and parameters in
one place called /data model/ and generate all kinds of code and
documentation from it, instead of spending a lot of time trying to
keep everything in sync and inevitably failing.

Unfortunately, the existing data modeling solutions are extremely
heavy and nasty to deal with. One doesn't want to mess with YANG
compilers and proprietary libraries for a mere small tool, and it's
understandable. /Lee/ attempts to implement a /reasonably useful/ data
modeling DSL, some bare-bones libraries for CLI and config file
parsing, together with the model validation routines in under 3000 LOC
or so.

* Basic examples

** Type reflection

/Lee/ provides a /base model/ containing definitions necessary for
veryfying plain Erlang terms. Let's use it to verify some basic types:

#+BEGIN_SRC erlang
-include("lee_types.hrl").

main() ->
  Model = lee:base_model(),
  ok = lee:validate_term(Model, boolean(), true),
  ok = lee:validate_term(Model, boolean(), false),
  {error, "Expected true | false, got 42"} =
    lee:validate_term(Model, boolean(), 42),
  ok = lee:validate_term(Model, string(), "Hi!"),
  {error, "Expected list(0..1114111), got [100, -1]"} =
    lee:validate_term(Model, string(), [100, -1]).
#+END_SRC

Now let's play with some custom types. =lee:type_refl/2= quasifunction
invokes a parse transform generating a /type reflection/ from a
dialyzer type spec. It takes two arguments: first one is the namespace
for the generated types, and the second one is a list of local type
definitions that should be included in the model.

#+BEGIN_SRC erlang
-include("lee_types.hrl").

-type stupid_list(A) :: {cons, A, stupid_list(A)}
                      | nil
                      .

-type foo(A) :: stupid_list(A)
              | list(A)
              .

main() ->
  %% Generate a model containing bar/1 type:
  Model0 = lee:type_refl([my, model], [foo/1]),
  %% Merge it with the Lee base model:
  {ok, Model} = lee_model:merge( lee:base_model()
                               , Model0
                               ),
  ok = lee:validate_term(Model, foo(atom()), [foo, bar]),
  ok = lee:validate_term(Model, foo(atom()), {cons, foo, {cons, bar, nil}}).
#+END_SRC

Note: you don't need to include all the types in the list, Lee will
figure out the dependencies.

Note: opaque types can't be reflected (obviously).

Note: =lee:type_refl= generates a local function with the same name as
the type. You will get a compilation error if you try to reflect a
type =foo/0= and there is already a function =foo/0=.

** Model validation

Validating terms against typespecs in the runtime is cool and all, but
it's still a chore. It can be avoided be defining a custom data model
describing configuration parameters and their types. Let's create one:

#+BEGIN_SRC erlang
-include("lee_types.hrl").

main(Config) ->
    %% Define a custom data model:
    MyModel = #{ foo => {[value]
                        , #{ mandatory => true
                           , type => boolean()
                           , oneliner => "This values controls fooing"
                           , doc => "Blah blah blah"
                           }}
               , bar => {[value]
                        , #{ type => integer()
                           , oneliner => "This values controls baring"
                           , doc => "Blah blah blah"
                           , default => 42
                           }}
               },
    %% [value] is a `metatype' which specifies that [foo] and [bar] can be
    %% retrieved from a config. There may be multiple metatypes; their
    %% attributes are row-polymorphic

    %% Merge our model with a few standard ones:
    {ok, Model} = lee_model:merge([ %% Define erlang native types:
                                    lee:base_model()
                                    %% Define some basic metatypes, like `value'
                                  , lee:base_metamodel()
                                    %% Specify that the config is stored as a simple map:
                                  , lee_map_getter:model()
                                  , Model0
                                  ]),
    %% Now we can verify `Config' against the model:
    case lee:validate(Model, Config) of
      {ok, _Warnings} ->
          %% And finally we can read values from the config
          %% And they do have the specified types!
          {ok, Foo} = lee:get(Model, Config, [foo]),
          {ok, Bar} = lee:get(Model, Config, [bar]),
          ok;
      {error, Errors, _Warnings} ->
          io:format("Invalid config: ~p~n", [Errors]),
          halt(1)
     end.
#+END_SRC


* Name?

This library is named after Tsung-Dao Lee, a physicist who predicted
P-symmetry violation together with Chen-Ning Yang.
